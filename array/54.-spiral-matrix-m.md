# 54. Spiral Matrix \(M\)

## [Problem link](https://leetcode.com/problems/spiral-matrix/)

### Problem statement

Given a matrix of _m_ x _n_ elements \(_m_rows, _n_ columns\), return all elements of the matrix in spiral order.

**Example 1:**

```text
Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

```text
Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

### Hints:

**hint 1:**  Well for some problems, the best way really is to come up with some algorithms for simulation. Basically, you need to simulate what the problem asks us to do.

**hint 2:** We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column and then we move inwards by 1 and then repeat. That's all, that is all the simulation that we need.

**hint 3:** Think about when you want to switch the progress on one of the indexes. If you progress on `i`out of `[i, j]`, you'd be shifting in the same column. Similarly, by changing values for `j`, you'd be shifting in the same row. Also, keep track of the end of a boundary so that you can move inwards and then keep repeating. It's always best to run the simulation on edge cases like a single column or a single row to see if anything breaks or not.

### Analysis:

Use hints!

The moving order is starting from `[0 , 0]` , and then right-down and left up. THe key is to identify the turning point. Use four variables `t, d, l, r`  to represent 4 boundaries.

* initialize `t, d, l, r`to be the boundaries of the original matrix.
* define a direction array `dir.`if 

### Solution

```python
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        R = len(matrix)
        C = len(matrix[0])
        row = [i for i in range(R)]
        col = [ i for i in range(C-1, -1, -1)]
        p = [(row[0], col[0])]
        q = []
        while p:
            r, c = p.pop()
            for ele in matrix[r]:
                q.append(ele)
            for i in range(r+1, R, 1):
                q.append(matrix[i][c])
            p.append((i, c))
        
        
        
        
```

### References

### 

